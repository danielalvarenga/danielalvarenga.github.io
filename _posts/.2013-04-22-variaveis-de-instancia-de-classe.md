---
layout: post
title: Variáveis de Instância da Classe
description: Entenda como é possível definir variáveis de classe como variáveis de instância de uma classe, e porque essa geralmente é a melhor opção
tags:
  - ruby
  - variaveis
  - metaprogramacao
---

O modo padrão de se definir variaveis de classe em ruby é usando a sintaxe @@my_var, como mostrado a seguir:

{% highlight ruby %}
class MyClass
  @@my_var = "My class variable !"

  def self.my_class_method
    puts @@my_var
  end
end

MyClass.my_class_method
# My class variable !
{% endhighlight ruby %}

Note que o método é necessario para acessar a variavel, já que toda variavel de classe ou instância em ruby é privada, ou seja, só é possivel accessá-la de fora da classe através de um método.

Esse modo de criar variaveis de classe, porém, pode trazer consequencias indesejaveis. Ao se definir uma variavel de classe usando a sintaxe @@my_var, toda subclasse dela poderá alterar essa variavel, fazendo tanto a super classe quanto todas as outras subclasses dela apontarem para esse novo valor !

{% highlight ruby %}
class MyClass
  @@my_var = "My class variable !"

  def self.my_class_method
    puts @@my_var
  end
end

MyClass.my_class_method
# My class variable !
# => nil

class OtherClass < MyClass
  @@my_var = "A new value..."
  def self.other_class_method
    puts @@my_var
  end
end

MyClass.my_class_method
# A new value...
# => nil

OtherClass.other_class_method
# A new value...
# => nil
{% endhighlight ruby %}

A modo de contornar esse problema é lembrar que em ruby tudo é um objeto, logo... uma classe também é. De fato, toda classe é uma instância da classe Class.

{% highlight ruby %}
class MyClass; end
MyClass.class
# Class
{% endhighlight ruby %}

Já que toda classe é um objeto, é razoavel então quere definir uma variavel de instância nesse objeto:

{% highlight ruby %}
class MyClass
  @my_var = "Some class instance variable..."
  def self.my_method
    puts @my_var
  end
end

MyClass.my_var
# Some class instance variable...
{% endhighlight ruby %}

Desse modo, uma subclasse de MyClass não seria capaz de alterar o valor de @my_var como era o caso do exemplo anterior,
o que torna esse modo o mais seguro para se criar variaveis de classe, ou nesse caso, variaveis de instância da classe.

O exemplo dado foi o mais didático possivel, no mundo real você provavelmente iria abrir a singleton class do objeto e usar o attr_accessor para definir os métodos de leitura e escrita:

{% highlight ruby %}
class MyClass
  class << self
    attr_accessor :my_var
  end
end

MyClass.my_var
# Some class instance variable...
{% endhighlight ruby %}
